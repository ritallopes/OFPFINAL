# -*- coding: utf-8 -*-
"""Cópia de OFPFINAL-52target.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z2USCHuVM3FXvbwRB5YHowt8EGf1vTDm

#Caso de estudo :  Dependência de libs do python
"""

#importing libs
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import numpy as np
from operator import itemgetter

#arquivo csv contendo os vértices do grafo
nodes = pd.read_csv('nodes.csv')
nodes.head()

#configurando nome de colunas e index
nodes.columns = ['index', 'name', 'position']
nodes.set_index('index', inplace=True)
nodes.head()

sum(nodes.name.isna()) # existem duas observações sem identificação nominal

nodes[nodes.name.isna()]

nodes.position = nodes.position.str.extract(r'\[(.+)\]').iloc[:,0]
nodes.head()

#arquivo csv contendo as arestas do grafo
edges = pd.read_csv('edges.csv')
edges.head()

#mudando nomes das colunas
edges.columns  = ['source', 'target', 'lib', 'version']
#adicionando propriedade versão a partir de lib source
edges.iloc[:,3] = edges.iloc[:, 2].str.extract(r'\-(\d+.+)').iloc[:,0]

# pegando packages que são alvo de mais de 200 pacotes
more_target = pd.Series(edges.target.value_counts() > 200)
print(sum (more_target)) # 52 pacotes que são dependencias de mais de 10 pacotes
edges = edges[edges.target.isin(more_target[more_target].index)]

edges.target.unique()

edges['name_source'] = 'NaN'
edges.name_source = [nodes.loc[nodes.index == i,['name']].iloc[0,0] for i in edges.source]

edges['name_target'] = 'NaN'
edges.name_target = [nodes.loc[nodes.index == i,['name']].iloc[0,0] for i in edges.target]

print(sum(edges.source == 1) + sum(edges.source == 34998)) # 391 com nan em source
print(sum(edges.target == 1) + sum(edges.target == 34998)) # 35758 com nan em target

edges.head()

edges.shape

edges = edges[edges.name_source.notna()]  #remove nan of source

edges = edges[edges.name_target.notna()]  #remove nan of source

edges.shape

nodes.shape

nodes = nodes[nodes.name.notna()] #removing names with na of nodes
nodes.shape

edges.target.value_counts()

"""#Criando Grafo"""

G = nx.DiGraph()
G.add_nodes_from(nodes.name)

G.add_edges_from([(s,t) for s,t in zip(edges.name_source, edges.name_target)]) # adicionando as arestas

nx.write_graphml(G, "dependencies_py.graphml")

nx.set_node_attributes(G, pd.Series(list(nodes.position.str.split(",")), index=nodes.name).to_dict(), 'pos')

print(nx.number_of_nodes(G))
print(nx.number_of_edges(G))
print(G.nodes.data())

print(nx.number_of_isolates(G)) #nós isolados
 G.remove_nodes_from(list(nx.isolates(G)))# removendo nós isolados

print(nx.number_of_nodes(G))
print(nx.number_of_edges(G))
print(G.nodes)

"""# ANÁLISES, MÉTRICAS, GRAU

##Matrizes e mais
"""

print(list(G.adj['labkit'])) # or list(G.neighbors(1))
print(nx.center(nx.Graph(G))) # ['beautifulsoup4', 'requests', 'six', 'docopt', 'docutils', 'gevent', 'pycrypto', 'distribute', 'lxml', 'argparse', 'pyyaml', 'jinja2', 'simplejson', 'mock', 'numpy', 'sphinx', 'python-dateutil', 'flake8', 'sqlalchemy', 'twisted', 'babel', 'psycopg2', 'click', 'flask', 'pillow', 'pytz', 'pep8']

"""##Densidade"""

nx.density(G) # de todas as comunicações possíveis 
#depois de remover isolados :0.00012889242764360713
#antes de remover isolados : 1.0850480288877642e-05

"""##Grau"""

print(G.in_degree)
'''Retorna o grau de um nó ou nós. O nodo em grau é o número de arestas apontando para o nodo.'''

import collections

degree_sequence = sorted([d for n, d in list(G.out_degree)], reverse=True)  # degree sequence
degreeCount = collections.Counter(degree_sequence)
deg, cnt = zip(*degreeCount.items())


fig, ax = plt.subplots()
plt.bar(deg, cnt, width=1, color="b")

plt.title("Degree Histogram")
plt.ylabel("Count")
plt.xlabel("Degree")
ax.set_xticks([d + 0.4 for d in deg])
ax.set_xticklabels(deg)

plt.show()
plt.savefig("hist_degree.png") # o que possui mais dependencia

def plt_in_degree(G):
  #Analysis in degree and plot 
  degree_sequence = sorted([d for n, d in list(G.in_degree)], reverse=True)
  dmax = max(degree_sequence)
  fig = plt.figure("Degree of dependencies graph Python", figsize=(8, 6))
  # Create a gridspec for adding subplots of different sizes
  axgrid = fig.add_gridspec(2, 4)

  #degree rank
  ax1 = fig.add_subplot(axgrid[0:, :2])
  ax1.plot(degree_sequence, "b-", marker="o")
  ax1.set_title("Degree Rank")
  ax1.set_ylabel("degree")
  ax1.set_xlabel("rank")

  #degree histogram
  ax2 = fig.add_subplot(axgrid[0:, 2:])
  ax2.bar(*np.unique(degree_sequence, return_counts=True))
  ax2.set_title("Degree histogram")
  ax2.set_xlabel("degree")
  ax2.set_ylabel("nº nodes")

  fig.tight_layout()
  plt.figure(figsize=(10,10))
  plt.savefig('in-degree-rank-histogram.png')
  plt.show() 

def plt_out_degree(G):
  #Analysis out degree and plot
  degree_sequence = sorted([d for n, d in list(G.out_degree)], reverse=True)
  dmax = max(degree_sequence)
  fig = plt.figure("Degree of dependencies graph Python", figsize=(8, 6))
  # Create a gridspec for adding subplots of different sizes
  axgrid = fig.add_gridspec(2, 4)

  #degree rank
  ax1 = fig.add_subplot(axgrid[0:, :2])
  ax1.plot(degree_sequence, "b-", marker="o")
  ax1.set_title("Degree Rank")
  ax1.set_ylabel("degree")
  ax1.set_xlabel("rank")

  #degree histogram
  ax2 = fig.add_subplot(axgrid[0:, 2:])
  ax2.bar(*np.unique(degree_sequence, return_counts=True))
  ax2.set_title("Degree histogram")
  ax2.set_xlabel("degree")
  ax2.set_ylabel("nº nodes")

  fig.tight_layout()
  plt.figure(figsize=(10,10))
  plt.savefig('out-degree-rank-histogram.png')
  plt.show()

plt_out_degree(G)
plt_in_degree(G)

plt.style.use('seaborn-whitegrid')
x = [G.out_degree(n) for n in G.nodes()]
y = [nx.clustering(nx.Graph(G), node) for node in G.nodes]
plt.plot(x, y, 'o', color='blue');

node_and_degree = list(G.out_degree())
nodes_sort= sorted(node_and_degree, key=itemgetter(1))
nodes_sort[-15:]

"""Ego"""

#MEDIDAS
##VIZINHOS
ego = "requests"
alters_1 = G[ego]
print(alters_1)

# nx.all_neighbors is the same of the "degree" of a node
nx.degree(G,ego)

ego = "requests"
n = set([ego]) 
n.update(G.neighbors(ego))
egonet = G.subgraph(n)
print(egonet.nodes())
print(egonet.edges())

from operator import itemgetter
# find node with largest degree
node_and_degree = list(G.out_degree())
(largest_hub, degree) = sorted(node_and_degree, key=itemgetter(1))[-1]

# Create ego graph of main hub
hub_ego = nx.ego_graph(G, largest_hub)

# Draw graph
pos = nx.spring_layout(hub_ego)
nx.draw(hub_ego, pos, node_color="b", node_size=50, alpha=0.7, with_labels=True, font_size=12)

# Draw ego as large and red
options = {"node_size": 300, "node_color": "r"}
nx.draw_networkx_nodes(hub_ego, pos, nodelist=[largest_hub], **options)
fig = plt.figure("Ego Graph", figsize=(10, 10))
plt.savefig('egograph52.png')
plt.show()

"""##Clustering"""

ego = 'requests'
cc = nx.clustering(nx.Graph(G), ego) #forçar transformação em grafo não direcionado
print(cc)
ce = nx.clustering(nx.Graph(G))
print(ce)
acc = nx.average_clustering(nx.Graph(G))
print(acc)

plt.hist([nx.clustering(nx.Graph(G), node) for node in G.nodes])
plt.title('Clustering')
plt.xlabel('Clustering')
plt.ylabel('Frequência')
plt.show()

'''
Se o coeficiente de agrupamento de um nó for 1, o nó participa de todos os triângulos possíveis envolvendo qualquer par de seus vizinhos; a rede egocêntrica de tal nó é um gráfico completo.
Se o coeficiente de agrupamento de um nó for 0, não há dois nós na vizinhança conectados; a rede egocêntrica de tal nó é uma estrela.
Pense no coeficiente de agrupamento como uma medida de "estrelato".'''

"""##Closeness Centrality"""

nx.draw_networkx_edges(G,pos=nx.circular_layout(G))
nodes=nx.draw_networkx_nodes(G,
                 pos=nx.circular_layout(G),
                 node_color=list(nx.closeness_centrality(G).values()),
                 cmap=plt.cm.jet,
                 vmin=0,vmax=1)

plt.axis("off")
plt.colorbar(nodes)
plt.show()

"""#Grafo com Matplotlib

"""

nx.draw(G, node_size=4, node_color="red", alpha=0.7, linewidths=4)
fig = plt.figure("Dependencies graph Python", figsize=(8, 8))
plt.savefig("plt51.png")

len(edges.target.unique())

"""#Grafo com plotly

"""



edge_x = []
edge_y = []
for edge in G.edges():
    x0, y0 = G.nodes[edge[0]]['pos']
    x1, y1 = G.nodes[edge[1]]['pos']
    edge_x.append(x0)
    edge_x.append(x1)
    edge_x.append(None)
    edge_y.append(y0)
    edge_y.append(y1)
    edge_y.append(None)

edge_trace = go.Scatter(
    x=edge_x, y=edge_y,
    line=dict(width=0.5, color='#888'),
    hoverinfo='none',
    mode='lines')

node_x = []
node_y = []
for node in G.nodes():
    x, y = G.nodes[node]['pos']
    node_x.append(x)
    node_y.append(y)

node_trace = go.Scatter(
    x=node_x, y=node_y,
    mode='markers',
    hoverinfo='text',
    marker=dict(
        showscale=True,
        # colorscale options
        #'Greys' | 'YlGnBu' | 'Greens' | 'YlOrRd' | 'Bluered' | 'RdBu' |
        #'Reds' | 'Blues' | 'Picnic' | 'Rainbow' | 'Portland' | 'Jet' |
        #'Hot' | 'Blackbody' | 'Earth' | 'Electric' | 'Viridis' |
        colorscale='Electric',
        reversescale=True,
        color=[],
        size=10,
        colorbar=dict(
            thickness=15,
            title='Pacotes conectados',
            xanchor='left',
            titleside='right'
        ),
        line_width=2))

node_adjacencies = []
node_text = []
for node, adjacencies in enumerate(G.adjacency()):
    node_adjacencies.append(len(adjacencies[1]))
    node_text.append(str(len(adjacencies[1]))+' conexões')

node_trace.marker.color = node_adjacencies
node_trace.text = node_text
node_trace.marker.size = node_adjacencies

fig = go.Figure(data=[edge_trace, node_trace],
             layout=go.Layout(
                title='<br>Grafo de dependência Python',
                titlefont_size=16,
                showlegend=False,
                hovermode='closest',
                margin=dict(b=20,l=5,r=5,t=40),
                annotations=[ dict(
                    text="Grafo de rede de dependência de pacotes Python",
                    showarrow=False,
                    xref="paper", yref="paper",
                    x=0.005, y=-0.002 ) ],
                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False))
                )
fig.show()

"""#Grafo com nxviz"""

!pip install nxviz

# Import necessary modules to use Circos plot
import matplotlib.pyplot as plt
from nxviz import CircosPlot 

# create an egocentric network from ego and G
egonet = nx.ego_graph(G, ego)

# Create the CircosPlot object: c
c = CircosPlot(egonet,
               node_labels=True,
               figsize = (15,10),
               nodeprops={"radius": 0.5},
               #node_label_layout="rotation",
               #node_label_layout="numbers",
               fontsize=12
               )

# find ego node
for i,label in enumerate(c.nodes):
  if label == ego:
    ego_index = i
    break

# Draw c to the screen
c.node_colors[ego_index] = "red"
c.draw()
c.figure.tight_layout()

# Display the plot
plt.title("Egocentric Network from node \"{}\"".format(ego))
plt.show()